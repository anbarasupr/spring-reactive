							Redis Reddision
							----------------------

Jedis 
	Fast but not Thread safe and not scalable

Lettuce:
	Scalable and supports reactive streams
	Works Spring data redis
	
Redission:
	Scalable and supports reactive streams
	Works Spring data redis
	Excellent abstraction and has corresponding equivalent java collections

	
Exaples:
-----------------------------------------------------------------
RBucketReactive:
--------------------
RBucketReactive<String> bucket = this.client.getBucket("user:1:name", StringCodec.INSTANCE);
Mono<Void> set = bucket.set("sam");
Mono<Void> set = bucket.set("sam", 10, TimeUnit.SECONDS);
Mono<Void> get = bucket.get().doOnNext(System.out::println).then();


RBucketReactive<Student> bucket = this.client.getBucket("student:1", new TypedJsonJacksonCodec(Student.class));


RAtomicLongReactive:
--------------------
RAtomicLongReactive atomicLong = this.client.getAtomicLong("user:1:visit");


RMapReactive:
--------------------
// Map<Integer, Student>
TypedJsonJacksonCodec codec = new TypedJsonJacksonCodec(Integer.class, Student.class);
RMapReactive<Integer, Student> map = this.client.getMap("users", codec);
Student student1 = new Student("sam", 10, "atlanta", List.of(1, 2, 3));
Mono<Student> mono1 = map.put(1, student1);


RMapCacheReactive:
--------------------
// Map<Integer, Student>
TypedJsonJacksonCodec codec = new TypedJsonJacksonCodec(Integer.class, Student.class);
RMapCacheReactive<Integer, Student> mapCache = this.client.getMapCache("users:cache", codec);
Student student1 = new Student("sam", 10, "atlanta", List.of(1, 2, 3));
Mono<Student> st1 = mapCache.put(1, student1, 5, TimeUnit.SECONDS);

// access students
mapCache.get(1).doOnNext(System.out::println).subscribe();


RLocalCachedMap:
--------------------
LocalCachedMapOptions<Integer, Student> mapOptions = LocalCachedMapOptions.<Integer, Student>defaults()
.syncStrategy(LocalCachedMapOptions.SyncStrategy.NONE)
.reconnectionStrategy(LocalCachedMapOptions.ReconnectionStrategy.CLEAR);

RLocalCachedMap<Integer, Student> studentsMap = RedissonConfig().getClient().getLocalCachedMap(
		"students",
		new TypedJsonJacksonCodec(Integer.class, Student.class),
		mapOptions
);
Student student1 = new Student("sam", 10, "atlanta", List.of(1, 2, 3));
studentsMap.put(1, student1);


RListReactive:
--------------------
RListReactive<Long> list = this.client.getList("number-input", LongCodec.INSTANCE) 


RQueueReactive:
--------------------
RQueueReactive<Long> queue = this.client.getQueue("number-input", LongCodec.INSTANCE);
Mono<Void> queuePoll = queue.poll() // poll - polls from start position since it is a queue
		

RDequeReactive:
--------------------
RDequeReactive<Long> deque = this.client.getDeque("number-input", LongCodec.INSTANCE);
Mono<Void> stackPoll = deque.pollLast() // pollLast - polls from last position since it is a stack
	

	
RBlockingDequeReactive<Long> msgQueue = this.client.getBlockingDeque("message-queue", LongCodec.INSTANCE);
RHyperLogLogReactive<Long> counter = this.client.getHyperLogLog("user:visits", LongCodec.INSTANCE);
RTopicReactive topic = this.client.getTopic("slack-room1", StringCodec.INSTANCE);


RBatchReactive batch = this.client.createBatch(BatchOptions.defaults());
RListReactive<Long> list = batch.getList("numbers-list", LongCodec.INSTANCE);
RSetReactive<Long> set = batch.getSet("numbers-set", LongCodec.INSTANCE);
for (long i = 0; i < 500_000; i++) {
	list.add(i);
	set.add(i);
}
StepVerifier.create(batch.execute().then()).verifyComplete();



RTransactionReactive transaction = this.client.createTransaction(TransactionOptions.defaults());
RBucketReactive<Long> user1Balance = transaction.getBucket("user:1:balance", LongCodec.INSTANCE);
RBucketReactive<Long> user2Balance = transaction.getBucket("user:2:balance", LongCodec.INSTANCE);
this.transfer(user1Balance, user2Balance, 50)
	.thenReturn(0)
	.map(i -> (5 / i)) // some error
	.then(transaction.commit())
	.doOnError(System.out::println)
	.onErrorResume(ex -> transaction.rollback())
	.subscribe();



RScoredSortedSetReactive<String> sortedSet = this.client.getScoredSortedSet("student:score", StringCodec.INSTANCE);



LocalCachedMap : Get the notification from redis when a key is expire:
-----------------------------------------------------------------------------------------
config set notify-keyspace-events AKE 		-- need this command to get the expired events from Redis.
https://redis.io/docs/manual/keyspace-notifications/

// LocalCachedMap is used to cache the whole hash in the application itself to avoid to going to redis in network
// and also we can set the time to live in the application
// if any updates happen, it will publish to all the application who are subcribed to it

/* if any update happens in redis,
 * SyncStrategy.NONE - do not publish to any apps if any update happens in redis and the redis is have the updated data and apps not
 * SyncStrategy.INVALIDATE - removes the invalidate data in other instances and upon requesting, apps will get the new data
						-	 Invalidate local cache entry across all LocalCachedMap instances on map entry change. Broadcasts map entry hash (16 bytes) to all instances.
 * SyncStrategy.UPDATE  - publish to all instance with latest data and get reflected in apps
 * 
 * ReconnectionStrategy.CLEAR - if the connection b/w app and redis is down for a while due to redis is down or any, 
 * the app will serve the data with its local copy  and the connection is alive,
 * the app data get cleared and get the latest from redis
 * eventhough the SyncStrategy is update redis cannot publish new data to the app due to its connectivity issue.
 * ReconnectionStrategy.NONE - the client will serve the data always with its local copy irrespective of any update happens in redis by other apps
 * */


/* UPDATE, NONE - app1 gets the data, app2 updates the data in redis, 
* redis publish the latest data to apps  due to SyncStrategy is UPDATE
* so app1 gets the latest data,  
*
*/

/* NONE, NONE - app1 gets the data, app2 updates the data in redis, 
* redis does not publish the latest data to apps due to SyncStrategy is none
* so app1 serve the stale data
*
*/

/* NONE, CLEAR - app1 gets the data, app2 updates the data in redis, 
* redis does not publish the latest data to apps due to SyncStrategy is none
* app1 still serves the local stale data, make redis down and broke the connection, 
* app1 still serves the local stale data,
* make redis up and reconnection happens from app1 to redis, 
* now app1 gets the latest data due to ReconnectionStrategy strategy clear even though SyncStrategy is none
*
* The app gets the latest data whenever app reconnects to redis due to connection breakout with app and the redis
* and app tries to reconnect and the latest data. If there is reconnection happens, it will serve the stale data
*
*/

/* UPDATE, CLEAR - app1 gets the data, app2 updates the data in redis, 
* redis publish the latest data to apps due to SyncStrategy is Update
* app1 serves the latest data, make redis down and broke the connection, 
* app1 still serves the local stale data,
* make redis up and reconnection happens from app1 to redis, 
* now app1 still get the latest data again from redis due to ReconnectionStrategy strategy clear
*/


HyperLogLog:	RHyperLogLogReactive
------------------------------------

Propabilitistic data structure - gives estimation close to actual result without storing the unique datasets

In a heavy user loads, it is required to track unique products that user purchasing. In this case, Set can be used and grows large, the performance will not be good
Here HyperLogLog is suggested if it is ok to have a  estimation close to actual result without storing the unique datasets
The HyperLogLog size would be 12.5 kb and will not occupy more memory


HyperLogLog is a probabilistic data structure that is used to estimate the number of distinct elements in a multiset or a stream of data. 
The basic idea is to count the number of distinct elements in large datasets



Message Queue and Pub/Sub:	RBlockingDequeReactive
--------------------------------------------------
In Message Queue, there will  be a producer who keeps on adding messages into Queue. 
We can have any number of consumers to process the messages.
If there are no comsumers, messages will be waiting in the queue. 
So whenever consumers come online, they can poll and start processing the messages.
Also messages would be distributed among the consumers if consumers are many.

Consider producer produced messages 1 to 10. Consumer one take item 1 and consumer 2 cannot take item 1 since it is taken by another consumer.
So no duplicate processing


Pub/Sub - Like announcements.
When the publisher publish the information, every subscriber can listen the information. But they have to be in online
Example : slack, chat applications uses this model

Also LocalCachedMap uses  this model.


Reddision Summary:
-----------------
Redis client library for java
Much better abstraction compared other libraries
Behind the scenes, it uses the Redis commands and givesmore abstraction to the developers

Redis:											Reddision											
------------									------------
SET Key Value									Bucket/ AtomicLong
Hash											Map, MapCache, LocalCacheMap
List											List, Queue, Deque, MessageQueue
Set												Set
SortedSet										SortedSet, PriorityQueue


Batch Commands:
 - to save network round           
 - reactive objects are proxy objects and used without any subscriptions
 
Transaction;	
 - make a set of commands atomic (prefer LuaScript)

Pub/Sub:
 - Message Broadcasting (LocalCacheMap)
 
